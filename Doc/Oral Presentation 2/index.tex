\documentclass[article]{report} % Type of document

\usepackage[utf8]{inputenc}    		 	% Encoding
\usepackage[english]{babel}			% Language
\usepackage{geometry}           			% Page margin
\usepackage{graphicx}           			% For images
\usepackage{newcent}            			% Font
\usepackage{color}              			% Colors
\usepackage{listings}           			% Lists
\usepackage[footnote, nolist]{acronym}	% Acronyms
\usepackage[absolute, overlay]{textpos}	% Text positioning

\usepackage{fancyhdr}          			 % We might have a need for them
\usepackage{float}
\usepackage{tabularx}

\usepackage{latexsym}
\usepackage{pdfpages}
\usepackage{tikz}
\usepackage{ifthen}
\usepackage{wrapfig}
\usepackage{textcomp}
\usepackage{multicol}

\setlength{\columnsep}{1cm}
\setlength{\TPHorizModule}{\paperwidth}	% Used for textblock
\setlength{\TPVertModule}{\paperheight}	% Used for textblock

\title {Oral Presentation 1}
\parskip = 0.25cm              % Summary options (spaces between lines)

% Margin
\geometry{tmargin=2.5cm, bmargin=1.5cm, lmargin=2.5cm, rmargin=2cm}

\definecolor{blue}{rgb}{0.13,0.29,0.46}
\definecolor{red}{rgb}{1,0,0}
\definecolor{couleur_titre}{rgb}{0.20, 0.45, 0.80}
\definecolor{couleur_nom}{rgb}{0.11, 0.6, 0.18}

\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\contentsname}{Table of contents}

% Title at the top of the page
\pagestyle{fancyplain} \chead{}\lhead{\textit{Team Dedalus}} \rhead{\textcolor{couleur_titre}{\emph{\textit{Project: SkyLands}}}}

\title {Book of specifications}
\author {Romain\and Renaud\and Aenora\and Erwan}
\date {}

%
% Document
%
\begin{acronym}
	\acro{OO}{Oriented-Object}
	\acro{RTS}{Real Time Strategy}
	\acro{FPS}{First Person Shooter}
	\acro{Mogre}{Managed Object-Oriented Graphics Rendering Engine}
	\acro{API}{Application Progamming Interface}
	\acro{GUI}{Graphical User Interface}
	\acro{MyGUI}{Multilayer and overlappable GUI System}
	\acro{IDE}{Integrated Developement Environment}
	\acro{AI}{Artificial Intelligence}
	\acro{NPC}{Non Player Character}
	\acro{UML}{Unified Modeling Language}
	\acro{PHP}{PHP : Hypertext Preprocessor}
	\acro{ORM}{Object-Relational Mapping}
	\acro{MVC}{Model View Controller}
	\acro{OGRE}{Object-Oriented Graphics Rendering Engine}
\end{acronym}
\begin{document}
	\thispagestyle{empty}
  	\begin{titlepage} 
		\vspace*{1cm} 
  		\begin{center} 
  			{\huge{\textsc{1st Oral} \\ ~ \\{\large From}\\ ~\\ Team \\  ~ \\ }}
	  		\includegraphics[width = 14cm]{images/Titles/Dedalus.png}
			\\ ~ \\ ~ \\ ~ \\ ~ \\ ~ \\ ~ \\ ~ \\ ~ \\ ~ \\ ~ \\ ~ \\ ~ \\ ~ \\ ~ 
		\end{center}
  		\hfill {\large Romain \textsc{Biessy}}
  		\hfill {\large Renaud \textsc{Gaubert}}
  		\hfill {\large Aenora \textsc{Tye}}
  		\hfill {\large Erwan  \textsc{Vasseure}}
  	\end{titlepage} 

  	\tableofcontents
  		\pagenumbering{arabic}
  		\newpage
		
		\chapter{\textcolor{blue}{Introduction}}
 											
  		\chapter{\textcolor{blue}{Communications}}
			\section{Twitter, Facebook and YouTube }
				
			\section{Web site}
				
		\chapter{\textcolor{blue}{Licencing}}

		\chapter{\textcolor{blue}{Terrain display}}
			\section{What was done}
				For the 1st oral presentation, the display system was the biggest problem we had, FPS were very low, around 30, even though we only displayed little Islands (5*5*5 chunks, which are 16*16*16 blocks tall).\\
This system consisted in displaying visible faces of each blocks a unique entity. MOGRE had troubles supporting thousands of facesat a time.

			\section{Optimizations}
				So we came up with another idea, which was a bit risky. Basically creating an entity in mogre is very simple :\\
As you can see, we only have to give the object position and to tell to draw a quad (which is actually a shortcut to creating 2 triangles).
Basically, the idea we had was to gather all visible blocks of the same material in an instance of an object (which was called multiblock). However this was not simple for 2 reasons :
\begin{itemize}
\item We cannot tell the material to delete a face at a certain position neither can we add new faces to it
\item We wanted blocks which had more than one texture on it (for example the grass cube doesn't have the same texture on the the top face than on the bottom
 face)
 \end {itemize}

First of all you need to understand our architecture : 
%<image>World contient une ‚Äùle, qui contient une liste de chunk qui contiennent chacun un tableau de blocks</image>

As you can see here each chunk contains an array of block. At first we stored in each cell a new instance of an object (The cube object) but
!we made some changes and we now !instanciet! once blocks of each material and the store the references to the corresponding block in the array.\\
			<explain>
However with this model, we can only have one unique texture per block. Therefore, using inheritance, we came 
up with the following idea : in a base class, we create an abstract method called getComposingFaces which returns the material.
In the derived class, if it needs multiple texture than it'll have to override this method, returning an array of string composed of the name of it's faces which would be 
</explain>\\

This system may seem a bit complicated, and it was, but it was totally worth the cost, we increased the FPS rate by 20, it now turns around 400. And, the Islands size were trippled, getting from 4*4 to 12*12 (on the x, z coordinates with y the height)
			\section{Results}
			
			\section{Sky}
				At the first oral, we presented you a sky using the lilbrary Caelum but then we wanted to try another well-known library : SkyX. Once again we actually used a wrapper of the original library coded in C++. We wanted to try another library so that we could choose the best for our game.\\
				
<<<<<<< HEAD
Unfortunately it appeared that even if SkyX is a great library in C++ its wrapper is much less interesting. Indeed many functions weren't implemented in the wrapper. This lack leads to a far less awesome render than in the C++ version. Besides we had lots of troubles integrating this library to our project because of the different existing versions of Mogre.\\
=======
Unfortunately it appeared that even if SkyX is a great library in C++ its wrapper is much less interesting. Indeed many functions weren't implemented in the wrapper. This lack leads to a far less bluffy render than in the C++ version. Besides we had lots of troubles integrating this library to our project beacause of the different existing versions of Mogre.\\
>>>>>>> 9cdd5c8fa7dd228b913eca62e4713a29192c1a2f

That's why we ended up choosing Caelum. But we didn't made this choice because it was the first we saw but because this is the best one we can have.

		\chapter{\textcolor{blue}{Player actions}}
			\section{Adding blocks}
				One of the downside of gathering all faces in one object is that you can't add faces to the object. Therefore we had to think a bit outside the object. What we did was the following : When the player adds cube to the terrain, we display the face as indepedent objects each and remember the position he added a block. When he has added 30 blocks, we launch a new thread whose role is to recreate each multiblocks that were modified.\\

		First he must change the list of Vector3 the instance of Multiblock has and add the blocks the player added. Then he must recreate the object and when it's done remove the old one and replace it with a new one.\\

		C\# having a thread system which is easy to handle, this part was pretty easy.
				
			\section{Removing them}
				On the other hand removing blocks from the scene was a tricky part. Because the function we needed was not implemented in C\# we had to get it from the C++ libraries. And, what's more, the function needed pointers so we had to use the unsafe option.\\
The basic idea is that a Manual Object is just an abstract layer to Vertex and Vertices. Thus we had to get the vertex buffer, Lock it, get the position of the first element and from there on tell what was the face number we wanted to access, and multiply this number by the "size" of a Vector3 this would set the pointer to the right position. From there on we only had to set for a face, it's 4 coords to 0 and check how many faces were visible.\\

However 2 problems arose : the first block with multiple structures, had to be dealt with in a separate way. \\
The second was that when removing a block, we had to refresh the surrounding blocks, thus most of the time creating faces which were not in the manual object (that was the cause of a bug). So we had to be careful not to suppress 

		\chapter{\textcolor{blue}{Terrain generation}}
			\section{A new structure}
				
			\section{Perlin 3d algorithm}
				
			\section{Biomes}
			
		\chapter{\textcolor{blue}{Buildings}}
			\section{Constructions blocks}
				Unlike in Minecraft, our player can build some presaved buildings. This is the basic of a Starcraft-like game. These buildings will allow the players to spawn some bots for his army and also to gather few basic resources.\\

We don't want the player to build all of the constructions block per block, all he will have to do is to place a "construction block". Then when he clicks this block, a menu opens and the player will have to give the required resources to start the construction. For now we haven't the inventory system with the actual resources of the player that's why the construction menu is very simple.
			
			\section{Saving and loading the structure}
			
		\chapter{\textcolor{blue}{Physics}}
			\section{Collisions}
<<<<<<< HEAD
				As we want the best of our game, we tried to implement the library MogreNewt. This library provides a physic engine and handle collisions detection. It is a powerful tool but it implies to add each cube one by one as a "Body" that is to say about 80 000 blocks. This leads to an important loss of FPS which is definitely what we don't want. Here you can see all the wires of the bodies including the character which was automatically created using its mesh file.\\

Eventually, we kept our system using the height points of each corner since we consider our character as a parallelepiped rectangle. This isn't an AABB collision algorithm because we look at the type of block there are next to the points.

=======
				As we want the best of our game, we tried to implement the library MogreNewt. This library provides a physic engine and handle collisions detection. It is a powerful tool but it implies to add each cube one by one as a "Body" that is to say about 80 000 blocks. This leads to an important loss of FPS which is definitely what we don't want. Here you can see all the wires of the bodies including the character which was automaticaly created using its mesh file. 
>>>>>>> 9cdd5c8fa7dd228b913eca62e4713a29192c1a2f
			\section{Jump}
				As promised our characters can now jump. Once the collisions with the floor worked this wasn't a hard task. We use a second order polynomial to determine the actual speed of the jump depending on the time since the character has jumped. Then our gravity system takes cares to make him fall.
				
		\chapter{\textcolor{blue}{Character}}

		\chapter{\textcolor{blue}{AI}}
			\section{Pathfinding}
				
			\section{A star (A*)}

		\chapter{\textcolor{blue}{Conclusion}}
				     		
\end{document}